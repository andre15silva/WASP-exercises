diff --git a/tmp/00b6cdfa-f4f8-4d87-9793-3ed8d24b3a2e_buggy.java b/tmp/270cb466-aac3-4ad3-95c2-46fe8e6b7242_fixed.java
index 4b7e1e4..ccfb790 100644
--- a/tmp/00b6cdfa-f4f8-4d87-9793-3ed8d24b3a2e_buggy.java
+++ b/tmp/270cb466-aac3-4ad3-95c2-46fe8e6b7242_fixed.java
@@ -1,52 +1,29 @@
     // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188
     Map<String, String> parsePaxHeaders(final InputStream i)
         throws IOException {
-        final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
-        // Format is "length keyword=value\n";
+        // TODO: the line below is a guess, but should work (read(150) seems to have been replaced by 
+        //       readLine() -- https://sourceforge.net/tracker/index.php?func=detail&aid=988816)
+        final Map<String, String> headers =
+            new HashMap<String, String>(globalPaxHeaders);
         while (true) { // get length
-            int ch;
-            int len = 0;
-            int read = 0;
-            while((ch = i.read()) != -1) {
-                read++;
-                if (ch == ' '){
-                    // Get keyword
-                    final ByteArrayOutputStream coll = new ByteArrayOutputStream();
-                    while((ch = i.read()) != -1) {
-                        read++;
-                        if (ch == '='){ // end of keyword
-                            final String keyword = coll.toString(CharsetNames.UTF_8);
-                            // Get rest of entry
-                            final int restLen = len - read;
-                            if (restLen == 1) { // only NL
-                                headers.remove(keyword);
-                            } else {
-                                final byte[] rest = new byte[restLen];
-                                final int got = IOUtils.readFully(i, rest);
-                                if (got != restLen) {
-                                    throw new IOException("Failed to read "
-                                                          + "Paxheader. Expected "
-                                                          + restLen
-                                                          + " bytes, read "
-                                                          + got);
+            final String line = IOUtils.readLine(i, CharsetNames.UTF_8);
+            if(line.startsWith(PAX_PREFIX)){ // ONLY PAX headers -- other headers break this
+                final String keywordValue = line.substring(PAX_PREFIX.length());
+                final int len = parsePaxLength(keywordValue);
+                if (len <= 0 ) {
+                    // Empty or but line then only contains a NL. Skip the PAX but lines
+                    continue;
+                }
+                final int read = readPredictions(line.length());
+                if (read < len) {
+                    throw new IOException("Failed to readPaxheader. Expected "
+                                          + len + " bytes, read "
+                                          + read);
                 }
                 // Drop trailing NL
-                                final String value = new String(rest, 0,
-                                                          restLen - 1, CharsetNames.UTF_8);
-                                headers.put(keyword, value);
-                            }
-                            break;
-                        }
-                        coll.write((byte) ch);
-                    }
-                    break; // Processed single header
-                }
-                len *= 10;
-                len += ch - '0';
-            }
-            if (ch == -1){ // EOF
+            } else if (line == null) { // EOF
                 break;
             }
         }
         return headers;
     }
