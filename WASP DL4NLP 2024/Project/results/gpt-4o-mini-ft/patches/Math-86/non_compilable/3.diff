diff --git a/tmp/25f52279-2f30-4dbd-adc2-4e1cddfce5fe_buggy.java b/tmp/b7b89966-e526-40d4-93ae-67b265f21116_fixed.java
index 0eef537..e93ad16 100644
--- a/tmp/25f52279-2f30-4dbd-adc2-4e1cddfce5fe_buggy.java
+++ b/tmp/b7b89966-e526-40d4-93ae-67b265f21116_fixed.java
@@ -1,74 +1,156 @@
     /**
      * Calculates the Cholesky decomposition of the given matrix.
      * @param matrix the matrix to decompose
      * @param relativeSymmetryThreshold threshold above which off-diagonal
      * elements are considered too different and matrix not symmetric
      * @param absolutePositivityThreshold threshold below which diagonal
      * elements are considered null and matrix not positive definite
      * @exception NonSquareMatrixException if matrix is not square
      * @exception NotSymmetricMatrixException if matrix is not symmetric
      * @exception NotPositiveDefiniteMatrixException if the matrix is not
      * strictly positive definite
      * @see #CholeskyDecompositionImpl(RealMatrix)
      * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD
      * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD
      */
     public CholeskyDecompositionImpl(final RealMatrix matrix,
                                      final double relativeSymmetryThreshold,
                                      final double absolutePositivityThreshold)
         throws NonSquareMatrixException,
                NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {
 
         if (!matrix.isSquare()) {
             throw new NonSquareMatrixException(matrix.getRowDimension(),
                                                matrix.getColumnDimension());
         }
 
         final int order = matrix.getRowDimension();
         lTData   = matrix.getData();
         cachedL  = null;
         cachedLT = null;
 
         // check the matrix before transformation
         for (int i = 0; i < order; ++i) {
 
             final double[] lI = lTData[i];
 
             if (lTData[i][i] < absolutePositivityThreshold) {
                 throw new NotPositiveDefiniteMatrixException();
             }
             // check off-diagonal elements (and reset them to 0)
             for (int j = i + 1; j < order; ++j) {
                 final double[] lJ = lTData[j];
                 final double lIJ = lI[j];
                 final double lJI = lJ[i];
                 final double maxDelta =
                     relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));
                 if (Math.abs(lIJ - lJI) > maxDelta) {
                     throw new NotSymmetricMatrixException();
                 }
                 lJ[i] = 0;
            }
         }
 
         // transform the matrix
         for (int i = 0; i < order; ++i) {
 
             final double[] ltI = lTData[i];
 
             // check diagonal element
 
             ltI[i] = Math.sqrt(ltI[i]);
             final double inverse = 1.0 / ltI[i];
 
             for (int q = order - 1; q > i; --q) {
                 ltI[q] *= inverse;
                 final double[] ltQ = lTData[q];
                 for (int p = q; p < order; ++p) {
                     ltQ[p] -= ltI[q] * ltI[p];
                 }
             }
 
         }
 
+        /*
+         * The following should test for positive definiteness but there is a 
+         * bug with some tests (e.g. MatrixUtils.createRealMatrix(double[][]))
+         * e.g. for 
+         * 
+         * double[][] array = { 
+         *     { 0.40434286, -0.09376327, 0.30328980, 0.04909388 },
+         *     {-0.09376327,  0.10400408, 0.07137959, 0.04762857 },
+         *     { 0.30328980,  0.07137959, 0.30458776, 0.04882449 },
+         *     { 0.04909388,  0.04762857, 0.04882449, 0.07543265 },
+         * };
+         * 
+         * a = inv(sqrt(m[0][0])) * m[0][1] - inv(sqrt(m[0][0])) * m[0][2]
+         *   -        s       j          ->   -        s       j
+         *                                  <-        s       j
+         * libnum returns sqrt(1.0,1.0,1.0) = 1.0
+         * and libsdca returns sqrt(0.4957034304)
+         * This causes divergence with Cholesky lower bound, which returns 
+         *  --0.83869
+         * and libsnub returns 0.0
+         * 
+         * @TODO: Fix the order of tests:
+         *  at present this is consistent with the ordering of tests that fail.
+         *      lTData[i][i]
+         *      lTData[i][j]
+         * where lI is the some row j (== i) and j is above i so s
+         * e.g. m[0][0] <  0
+         * m[1][1] <  0
+         * 
+         * m[2][0] <  0
+         * m[2][2] <  0
+         * 
+         * and test for m[2][j] shouldn't be executed with another branch 
+         * to ensure off diagonal tests pass.
+         */
+        /*System.out.println(lTData[0]);
+        System.out.println(lTData[1]);
+        System.out.println(lTData[2]);
+        System.out.println(lTData[3]);*/
+        /*WEAVER SYSTEM-2906*/
+        for (int row = 0; row < order; ++row) {
+            for (int col = 0; col < order; ++col) {
+                if (Math.abs(lTData[row][col]) >= absolutePositivityThreshold) {
+                    continue;
+                }
+                else if ((row == col ) && ( lTData[col][col] > (absolutePositivityThreshold / 2.0))) {
+                    continue;
+                }
+                else if ((row != col ) && !(lTData[col][col] < 0.0) && !(lTData[row][row] < 0.0)){
+                    continue;
+                }
+                else{
+                  //System.out.println("SECOND ELSE");
+                  throw new NotPositiveDefiniteMatrixException();
+                }
+			}
+       }
+        //System.out.println("WENDY  "  + matrix.toString() +  lTData[0] + lTData[1] + lTData[2] + lTData[3]);
+        //System.out.println("END");
+        /*MatrixUtils.createRealMatrix( new double[][] {
+             **/ 
+    //        { 0.1180996862464730, 0.2284754768908767, 0.0366260214002271, 0.0324771529194036 },
+    //        { 0.0124927514911754, 0.1291608981672365, 0.0366260214002271, 0.0324771529194036 },
+    //        { 0.0366260214002271, 0.0366260214002271, 0.0592170542923730, 0.0138072624847695 },
+    //        { 0.0324771529194036, 0.0324771529194036, 0.0138072624847695, 0.0138072624847695 }
+    //        { 0.0321233318800841, 0.0321233318800841, 0.0138072624847695, 0.0138072624847695 }
+    //        { 0.0321233318800841, 0.0321233318800841, 0.0138072624847695, 0.0138072624847695 }
+    //        { 0.0321233318800841, 0.0321233318800841, 0.0138072624847695, 0.0138072624847695 }
+    //        { 0.0321233318800841, 0.0321233318800841, 0.0138072624847695, 0.0138072624847695 }
+   ///     } )
+     */
+    /*try {
+        System.out.println("Examining...");
+        System.out.println("\n"+matrix.toString());
+        System.out.println( "ltdata" + lTData[0].toString());
+        System.out.println( "ltdata" + lTData[1].toString());
+        System.out.println( "ltdata" + lTData[2].toString());
+        System.out.println( "ltdata" + lTData[3].toString());} catch(Exception e) {}
+  */
+    }//ENDEEK
+
+
     }  
