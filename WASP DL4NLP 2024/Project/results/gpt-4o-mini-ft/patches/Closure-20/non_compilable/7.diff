diff --git a/tmp/20d3753c-4e3a-433b-9a62-536ccba0ea9b_buggy.java b/tmp/b62ac310-3c51-4708-94c7-e5f8157352c8_fixed.java
index d4e6d48..1a54405 100644
--- a/tmp/20d3753c-4e3a-433b-9a62-536ccba0ea9b_buggy.java
+++ b/tmp/b62ac310-3c51-4708-94c7-e5f8157352c8_fixed.java
@@ -1,23 +1,31 @@
   private Node tryFoldSimpleFunctionCall(Node n) {
     Preconditions.checkState(n.isCall());
     Node callTarget = n.getFirstChild();
     if (callTarget != null && callTarget.isName() &&
           callTarget.getString().equals("String")) {
       // Fold String(a) to '' + (a) on immutable literals,
-      // which allows further optimizations
+      // which allows further optimizations on simple literals
+      // such as strings or ints.
       //
       // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
-      Node value = callTarget.getNext();
-      if (value != null) {
+      Node arg1 = callTarget.getNext();
+      if (arg1 != null && arg1.isAdd()) {
+        Node newArg = IR.add(IR.string("").srcref(callTarget),
+                              arg1.removeFirstChild());
+        Node newNode = IR.add(newArg, arg1.removeFirstChild()).srcref(callTarget);
+        newNode = n.getParent().replaceChild(n, newNode);
+        reportCodeChange();
+        return newNode;
+      } else if (arg1 != null && !arg1.isFunction()) {
         Node addition = IR.add(
             IR.string("").srcref(callTarget),
-            value.detachFromParent());
-        n.getParent().replaceChild(n, addition);
+            arg1.detachFromParent());
+        Node newNode = n.getParent().replaceChild(n, addition);
         reportCodeChange();
-        return addition;
+        return newNode;
       }
     }
     return n;
   }
