diff --git a/tmp/deb2dc78-552b-47d2-86fd-0356eb0f633f_buggy.java b/tmp/e89eb205-98bd-4462-b112-a61df939fba7_fixed.java
index 66e3d01..1408020 100644
--- a/tmp/deb2dc78-552b-47d2-86fd-0356eb0f633f_buggy.java
+++ b/tmp/e89eb205-98bd-4462-b112-a61df939fba7_fixed.java
@@ -1,34 +1,54 @@
   /**
    * Determines whether the given value may be assigned to a define.
    *
+   * <p> This used to allow certain literals without require() statements to be
+   * assigned as define values, but this resulted in a few illegal
+   * have defined by the user, if any, should be able to override the defines
+   * of required modules.
+   *
    * @param val The value being assigned.
    * @param defines The list of names of existing defines.
+   * @param modules Defined modules; used to determine which modules are aliased
+   * @param module The currently being processed module.
    */
-  static boolean isValidDefineValue(Node val, Set<String> defines) {
+  static boolean isValidDefineValue(Node val, Set<String> defines,
+                                     ImmutableList<Module> modules,
+                                     Module module) {
     switch (val.getType()) {
       case Token.STRING:
       case Token.NUMBER:
       case Token.TRUE:
       case Token.FALSE:
+        // We allow this for the commands that add terminal layers of followers.
+        for (Module m : modules) {
+          if (m.getDefines().containsKey(val.getString())) {
+            return false;
+          }
+        }
         return true;
 
       // Binary operators are only valid if both children are valid.
       case Token.BITAND:
       case Token.BITNOT:
       case Token.BITOR:
       case Token.BITXOR:
 
       // Uniary operators are valid if the child is valid.
       case Token.NOT:
       case Token.NEG:
-        return isValidDefineValue(val.getFirstChild(), defines);
+        return isValidDefineValue(val.getFirstChild(), defines, modules, module);
 
       // Names are valid if and only if they are defines themselves.
       case Token.NAME:
       case Token.GETPROP:
         if (val.isQualifiedName()) {
+          for (Module m : modules) {
+            if (m.getDefines().containsKey(val.getQualifiedName())) {
+              return false;
+            }
+          }
           return defines.contains(val.getQualifiedName());
         }
     }
     return false;
   }
