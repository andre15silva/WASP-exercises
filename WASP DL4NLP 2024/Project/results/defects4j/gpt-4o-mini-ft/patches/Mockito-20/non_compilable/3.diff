diff --git a/tmp/73148da0-90b3-4989-99b7-743fb6528072_buggy.java b/tmp/e2d4d43f-6d49-40f2-95a6-3dc45a1e771f_fixed.java
index f9a9b5b..4047291 100644
--- a/tmp/73148da0-90b3-4989-99b7-743fb6528072_buggy.java
+++ b/tmp/e2d4d43f-6d49-40f2-95a6-3dc45a1e771f_fixed.java
@@ -1,30 +1,59 @@
     public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {
         if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {
             throw new MockitoException("Serialization across classloaders not yet supported with ByteBuddyMockMaker");
         }
         Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(
                 settings.getTypeToMock(),
                 settings.getExtraInterfaces()
         );
         T mockInstance = null;
         try {
             mockInstance = classInstantiator.instantiate(mockedProxyType);
             MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;
             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));
 
             return ensureMockIsAssignableToMockedType(settings, mockInstance);
         } catch (ClassCastException cce) {
             throw new MockitoException(join(
                     "ClassCastException occurred while creating the mockito mock :",
                     "  class to mock : " + describeClass(mockedProxyType),
                     "  created class : " + describeClass(settings.getTypeToMock()),
                     "  proxy instance class : " + describeClass(mockInstance),
                     "  instance creation by : " + classInstantiator.getClass().getSimpleName(),
                     "",
                     "You might experience classloading issues, please ask the mockito mailing-list.",
                     ""
             ),cce);
         } catch (org.mockito.internal.creation.instance.InstantiationException e) {
             throw new MockitoException("Unable to create mock instance of type '" + mockedProxyType.getSuperclass().getSimpleName() + "'", e);
+        } catch (org.mockito.exceptions.misusing.NotAMockException e) {
+            if (!(mockInstance instanceof Class)) {
+                throw new MockitoException("Unable to create mock instance of type '" + settings.getTypeToMock().getSimpleName() + "' : the class is abstract", e);
+            }
+            // an abstract class can be mocked/spied on even if its constructors are inaccessible if we specify a class for mocking
+            // this happens in spyInnerClass case where the spy is private or package private.
+            // example where the abstract class is an inner class:
+            //    class Outer {
+            //        abstract class Inner {
+            //        }
+            //    }
+            // with @Mock and @Spy on Inner and is explicitly instructed to mock Outer 
+            // while the constructor of Inner is only accessible from Outer
+            // in which case its package-private and only Outer can be matched.
+            final Class mockType = settings.getMockType();
+            if ((mockType.getDeclaringClass() == null) || ((mockType.getDeclaringClass().isAnonymous() || (mockType.getDeclaringClass().getModifiers() & ACC_PRIVATE) > 0))) {
+                // inner classes must be placed on their own and cannot be injected
+                throw new MockitoException("chose an abstract class for mocking. This means that any spies on inner classes must be fully specified : "+mockType.getSimpleName());
+            }
+            if (mockType.isMemberClass() && !mockType.isStatic()) {
+                // Inner class must be recompilation-safe.
+                //  -- see http://www.docjar.com/html/api/org/mockito/internal/junit/report/MockitoJUnitReport.java.html for further information
+                throw new MockitoException("Unable to create mock instance of type '" + mockType.getSimpleName() + "' : the class is a non-static inner class.");
+            }
+            if (!settings.getExtraInterfaces().isEmpty()) {
+                // Default behaviour only proper classes must be instantiated.
+                mockType = mockType.getDeclaringClass();
+            }
+            return (T) classInstantiator.instantiate(mockType);
         }
     }
