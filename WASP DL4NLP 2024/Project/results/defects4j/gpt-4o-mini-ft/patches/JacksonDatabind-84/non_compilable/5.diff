diff --git a/tmp/b204a6b0-ebe2-486a-ad5d-0ae930d1e97e_buggy.java b/tmp/f696e41b-6198-4cc9-b182-8e1706344da7_fixed.java
index e69de29..3064975 100644
--- a/tmp/b204a6b0-ebe2-486a-ad5d-0ae930d1e97e_buggy.java
+++ b/tmp/f696e41b-6198-4cc9-b182-8e1706344da7_fixed.java
@@ -0,0 +1,117 @@
+package com.fasterxml.jackson.databind.jsontype.impl;
+
+import java.io.*;
+import java.util.*;
+
+import com.fasterxml.jackson.core.*;
+import com.fasterxml.jackson.databind.*;
+import com.fasterxml.jackson.databind.deser.DefaultDeserializationContext;
+import com.fasterxml.jackson.databind.deser.jsontype.*;
+import com.fasterxml.jackson.databind.module.SimpleModule;
+import com.fasterxml.jackson.databind.type.TypeFactory;
+
+/**
+ * Unit tests for [databind#2223], #595: Inconsistent behavior for deferred-type subtypes in
+ * JSON value serialization.
+ */
+public class JsonTypeInfo2223Test extends BaseMapTest
+{
+    static class Base {
+        int base;
+    }
+
+    static class Sub extends Base {
+        int sub;
+    }
+
+    /*
+    /**********************************************************************
+    /* Unit tests
+    /**********************************************************************
+     */
+
+    @JsonTypeInfo(use = JsonTypeInfo.Id.MINIMAL_CLASS, include = JsonTypeInfo.As.PROPERTY)
+    static class Deferred1 {
+        public String field;
+    }
+
+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.EXISTING_PROPERTY)
+    static class Deferred2 {
+        public String field;
+    }
+
+    @JsonTypeInfo(use = JsonTypeInfo.Id.CLASS, include = JsonTypeInfo.As.PROPERTY)
+    static class Deferred3 {
+        public String field;
+    }
+
+    // @JsonTypeInfo(use=JsonTypeInfo.Id.CLASS, include=JsonTypeInfo.As.PROPERTY)
+    static class Deferred4 {
+        public String field;
+    }
+
+    static final ObjectMapper mapper = new ObjectMapper();
+    
+    public void testObjectTypeInfo() throws Exception {
+        Reader r = new StringReader("{\"field\":\"1.0\"}");
+        Deferred1 result = mapper.readValue(r, Deferred1.class);
+        assertEquals("1.0", result.field);
+    }
+
+    public void testExistentialTypeInfo() throws Exception {
+        Reader r = new StringReader("{\"field\":\"1.0\"}");
+        Deferred2 result = mapper.readValue(r, Deferred2.class);
+        assertEquals("1.0", result.field);
+    }
+
+    public void testMinimalTypeInfo() throws Exception {
+        Reader r = new StringReader("{\"field\":\"1.0\"}");
+        Deferred3 result = mapper.readValue(r, Deferred3.class);
+        assertEquals("1.0", result.field);
+    }
+
+    public void testPropertyTypeInfo() throws Exception {
+        Reader r = new StringReader("{\"field\":\"1.0\"}");
+        Deferred4 result = mapper.readValue(r, Deferred4.class);
+        assertEquals("1.0", result.field);
+    }
+
+    public void testSubTypeLoadedAfterBaseType() throws Exception {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        Sub sub = new Sub();
+        String serialized = mapper.writeValueAsString(sub);
+        assertEquals("{\"base\":{\"base\":\"1.0\",\"sub\":\"2.0\"},\"sub\":2}", serialized);
+    }
+
+    public void testSubTypeLoadedBeforeBaseType() throws Exception {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        Base base = new Sub();
+        String serialized = mapper.writeValueAsString(base);
+        assertEquals("{\"base\":{\"base\":\"1.0\",\"sub\":\"2.0\"}}", serialized);
+    }
+
+    public void testBasePropertiesIncludedWhenDeserializingSubType() throws Exception {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        Base base = new Sub();
+        String content = String.format("{\"base\":{\"base\":1,\"sub\":2}}"); // required as 'sub' loaded AFTER base type
+        mapper.readValue(content, Base.class);
+    }
+
+    public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedAfterBaseType() throws IOException {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        tf.constructType(Base.class);
+        tf.constructType(Sub.class);
+        Sub sub = new Sub();
+        String serialized = mapper.writeValueAsString(sub);
+        assertEquals("{\"base\":1,\"sub\":2}", serialized);
+    }
+
+    public void testBasePropertiesIncludedWhenSerializingSubWhenSubTypeLoadedBeforeBaseType() throws IOException {
+        TypeFactory tf = TypeFactory.defaultInstance();
+        tf.constructType(Sub.class);
+        tf.constructType(Base.class);
+        Sub sub = new Sub();
+        String serialized = mapper.writeValueAsString(sub);
+        assertEquals("{\"base\":{\"base\":1,\"sub\":2},\"sub\":2}", serialized);
+    }
+}
\ No newline at end of file
