diff --git a/tmp/17638596-55e7-41f6-9c07-2a4ac86851a6_buggy.java b/tmp/384cb959-584b-440a-a7db-c6f81c5aa5a5_fixed.java
index fa6828a..887b1ac 100644
--- a/tmp/17638596-55e7-41f6-9c07-2a4ac86851a6_buggy.java
+++ b/tmp/384cb959-584b-440a-a7db-c6f81c5aa5a5_fixed.java
@@ -1,5 +1,24 @@
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+            field.setAccessible(true);
+            try {
+                final Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+                if(candidate instanceof Reference<Object>) {
+                    final Reference<Object> reference = (Reference<Object>) candidate;
+                    final Class<?> resolvedCandidateType = reference.$__resolve();
+                    final Field candidateField = (reference == awaitingInjectionClazz) ? fieldInstance.getClass() : mocks.stream()
+                                                                                                                        .filter(c -> c.getClass()
+                                                                                                                                      .equals(resolvedCandidateType))
+                                                                                                                        .findFirst()
+                                                                                                                        .get()
+                                                                                                                        .getClass()
+                                                                                                                        .getField(field.getName());
+                    field.set(fieldInstance, reference.$__get());
+                } else {
+                    field.set(fieldInstance, candidate);
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
         }
     }
