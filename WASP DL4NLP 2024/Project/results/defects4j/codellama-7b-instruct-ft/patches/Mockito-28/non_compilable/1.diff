diff --git a/tmp/e1964c89-5d62-4b8b-a27b-1a17592cc7d4_buggy.java b/tmp/43eec64c-19de-4c12-8002-9c955b98ddd5_fixed.java
index fa6828a..887b1ac 100644
--- a/tmp/e1964c89-5d62-4b8b-a27b-1a17592cc7d4_buggy.java
+++ b/tmp/43eec64c-19de-4c12-8002-9c955b98ddd5_fixed.java
@@ -1,5 +1,24 @@
     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {
         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {
-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+            field.setAccessible(true);
+            try {
+                final Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();
+                if(candidate instanceof Reference<Object>) {
+                    final Reference<Object> reference = (Reference<Object>) candidate;
+                    final Class<?> resolvedCandidateType = reference.$__resolve();
+                    final Field candidateField = (reference == awaitingInjectionClazz) ? fieldInstance.getClass() : mocks.stream()
+                                                                                                                        .filter(c -> c.getClass()
+                                                                                                                                      .equals(resolvedCandidateType))
+                                                                                                                        .findFirst()
+                                                                                                                        .get()
+                                                                                                                        .getClass()
+                                                                                                                        .getField(field.getName());
+                    field.set(fieldInstance, reference.$__get());
+                } else {
+                    field.set(fieldInstance, candidate);
+                }
+            } catch (IllegalAccessException e) {
+                throw new RuntimeException(e);
+            }
         }
     }
