diff --git a/tmp/1738eda1-3111-423c-beda-abcdfd6af6d7_buggy.java b/tmp/12c60767-78b7-440a-bf73-b95417ad095d_fixed.java
index eb9ce9f..641f94c 100644
--- a/tmp/1738eda1-3111-423c-beda-abcdfd6af6d7_buggy.java
+++ b/tmp/12c60767-78b7-440a-bf73-b95417ad095d_fixed.java
@@ -1,60 +1,148 @@
     /**
      * Look for a type declaration on a property assignment
      * (in an ASSIGN or an object literal key).
      *
      * @param info The doc info for this property.
      * @param lValue The l-value node.
      * @param rValue The node that {@code n} is being initialized to,
      *     or {@code null} if this is a stub declaration.
      */
     private JSType getDeclaredType(String sourceName, JSDocInfo info,
         Node lValue, @Nullable Node rValue) {
       if (info != null && info.hasType()) {
         return getDeclaredTypeInAnnotation(sourceName, lValue, info);
       } else if (rValue != null && rValue.isFunction() &&
           shouldUseFunctionLiteralType(
               JSType.toMaybeFunctionType(rValue.getJSType()), info, lValue)) {
         return rValue.getJSType();
       } else if (info != null) {
         if (info.hasEnumParameterType()) {
           if (rValue != null && rValue.isObjectLit()) {
             return rValue.getJSType();
           } else {
             return createEnumTypeFromNodes(
                 rValue, lValue.getQualifiedName(), info, lValue);
           }
         } else if (info.isConstructor() || info.isInterface()) {
           return createFunctionTypeFromNodes(
               rValue, lValue.getQualifiedName(), info, lValue);
         } else {
           // Check if this is constant, and if it has a known type.
           if (info.isConstant()) {
             JSType knownType = null;
             if (rValue != null) {
               if (rValue.getJSType() != null && !rValue.getJSType().isUnknownType()) {
                 // If rValue has a type-cast, we use the type in the type-cast.
                 // If rValue's type was already computed during scope creation,
                 // then we can safely use that.
                 return rValue.getJSType();
               } else if (rValue.isOr()) {
                 // Check for a very specific JS idiom:
                 // var x = x || TYPE;
                 // This is used by Closure's base namespace for esoteric
                 // reasons.
                 Node firstClause = rValue.getFirstChild();
                 Node secondClause = firstClause.getNext();
                 boolean namesMatch = firstClause.isName()
                     && lValue.isName()
                     && firstClause.getString().equals(lValue.getString());
                 if (namesMatch && secondClause.getJSType() != null
                     && !secondClause.getJSType().isUnknownType()) {
                   return secondClause.getJSType();
                 }
               }
             }
+            JSType type = registry.createAnonymousObjectType();
+            JSType ownerType = type;
+            Node n = rValue != null ? rValue : lValue;
+            Node parent = n.getParent().getParent();
+            boolean isVar = parent.isVar();
+            if (n.isQualifiedName()) {
+              String qName = n.getQualifiedName();
+              final JSType lValueType;
+              if (isVar) {
+                lValueType = scope.getDeclaredType(qName);
+                Node lValueNode = scope.getDeclaredVar(qName);
+                if (lValueNode != null) {
+                  ownerType = getDeclaredType(qName, lValueNode);
+                }
+              } else if (!info.isConstant()) {
+                Node rValueNode = n.getFirstChild().getNext();
+                JSDocInfo info1 = NodeUtil.getBestJSDocInfo(rValueNode);
+                if (info1 != null) {
+                  lValueType = getDeclaredTypeInAnnotation(
+                      qName, lValueNode, info1);
+                } else {
+                  lValueType = getInferredDeclaredTypeForCtorInputs(
+                      rValueNode, lValueNode);
+                }
+              } else {
+                // In this case, we've reached a value of constant enum,
+                // and the type of constant itself is always inferred based on it.
+                lValueType = null;
+              }
+              if (lValueType != null) {
+                // If someone writes, /** @const */ var x = {a: 1};
+                // then x might be a string|void, not {a: number}.
+                // If there's a property that's missing in an object literal,
+                // that too might be of enum type. For example,
+                // x = {a: 1, b: 2}.
+                // So we use the type that the property type has by default.
+                // TODO(dimvar): this is wrong for object literals with holes,
+                // but we can't use the type of 'void' here.
+                type = lValueType.isUnionType() ?
+                    lValueType : JSType.toMaybeObjectType(lValueType).toMaybeRecordType();
+              }
+            } else if (isVar) {
+              String qName = n.toGetterDef();
+              Node lValueNode = scope.getDeclaredVar(qName);
+              JSType lValueType1 = scope.getDeclaredType(qName);
+              final JSType lValueType;
+              if (lValueNode != null && lValueType1 != null) {
+                JSDocInfo info1 = NodeUtil.getBestJSDocInfo(lValueNode);
+                if (info1 != null) {
+                  lValueType = getDeclaredTypeInAnnotation(
+                      qName, lValueNode, info1);
+                } else {
+                  lValueType = getInferredDeclaredTypeForCtorInputs(
+                      lValueNode, null);
+                }
+              } else {
+                lValueType = null;
+              }
+              if (lValueType != null) {
+                type = JSType.toMaybeObjectType(lValueType).toMaybeRecordType();
+              }
+            }
+            if (info.isConstant()
+                || !type
+                    .isSubtypeOf(registry.createEquivalentObjectTypeForTesting(
+                        info.getInferredType()));
+                // We should warn about assigning constant literals of the wrong
+                // type.
+                ) {
+              JSType valueType = n.getFirstChild().getNext().getJSType();
+              JSType declaredType = registry.createAnonymousObjectType();
+              if (isVar) {
+                declaredType = type;
+              }
+              for (Map.Entry<String, Node> entry : n.getFirstChild().getNext()
+                   .getChildMap().entries()) {
+                String childPropName = entry.getKey();
+                Node child = entry.getValue();
+                JSType childType = child.getJSType();
+                // TODO(tjgq): figure out the scope.
+                JSType inferredType = inferredTypes.getType(child, scope);
+                declaredType = declaredType.toMaybeRecordType().
+                    withProperty(registry.createProperty(
+                        childPropName, childType, info.isConstant(),
+                        inferredType));
+              }
+              checkType(n, ownerType, declaredType, valueType);
+            }
           }
         }
       }
 
       return getDeclaredTypeInAnnotation(sourceName, lValue, info);
     }
