diff --git a/tmp/9526f653-77be-4bfe-921c-0361868916ae_buggy.java b/tmp/d01d3d73-7743-433e-8ba3-4ddcb5c3b24a_fixed.java
index d57736b..0271c13 100644
--- a/tmp/9526f653-77be-4bfe-921c-0361868916ae_buggy.java
+++ b/tmp/d01d3d73-7743-433e-8ba3-4ddcb5c3b24a_fixed.java
@@ -1,39 +1,91 @@
   /**
    * Suppose X is an object with inferred properties.
    * Suppose also that X is used in a way where it would only type-check
    * correctly if some of those properties are widened.
    * Then we should be polite and automatically widen X's properties for him.
    *
    * For a concrete example, consider:
    * param x {{prop: (number|undefined)}}
    * function f(x) {}
    * f({});
    *
    * If we give the anonymous object an inferred property of (number|undefined),
    * then this code will type-check appropriately.
    */
   private void inferPropertyTypesToMatchConstraint(
       JSType type, JSType constraint) {
     if (type == null || constraint == null) {
       return;
     }
 
-    ObjectType constraintObj =
-        ObjectType.cast(constraint.restrictByNotNullOrUndefined());
-    if (constraintObj != null && constraintObj.isRecordType()) {
-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());
+    ObjectType objType =
+        ObjectType.cast(type.restrictByNotNullOrUndefined());
     if (objType != null) {
+      ObjectType constraintObj;
+      if (constraint.isObject()) {
+        constraintObj =
+            ObjectType.cast(constraint.restrictByNotNullOrUndefined());
+      } else if (constraint.isUnion()) {
+        // NOTE(nicksantos): Issue 669: we need to widen the type.
+        // <code>
+        //   var obj = {a: 3, b: 4};
+        //   function f(var_args) {
+        //     return null;
+        //   }
+        //   var results = f(true, {}, obj);
+        //   var s1 = results.a;
+        //   var s2 = results.b;
+        // </code>
+        constraintObj = ObjectType.cast(objType);
+      } else {
+        return;
+      }
+      if (constraintObj != null) {
+        // Some additional logic to handle issue 669
+        boolean isVarargs = false;
+        ObjectType objTypeObj =
+            ObjectType.cast(objType.restrictByNotNullOrUndefined());
+        if (objTypeObj != null) {
+          JSType propType = null;
+          for (String p : objTypeObj.getOwnPropertyNames()) {
+            propType = objTypeObj.getPropertyType(p);
+            if (propType != null) {
+              break;
+            }
+          }
+          boolean isIssue669 = false;
+          JSType nativeUndefined = getNativeType(VOID_TYPE);
+          isIssue669 = propType != null && propType.isUnion() &&
+              propType.isSubtype(nativeUndefined);
+          isVarargs = isIssue669 && !constraintObj.hasProperty(p);
+        }
+        if (!isVarargs) {
           for (String prop : constraintObj.getOwnPropertyNames()) {
             JSType propType = constraintObj.getPropertyType(prop);
             if (!objType.isPropertyTypeDeclared(prop)) {
               JSType typeToInfer = propType;
               if (!objType.hasProperty(prop)) {
                 typeToInfer =
                     getNativeType(VOID_TYPE).getLeastSupertype(propType);
               }
               objType.defineInferredProperty(prop, typeToInfer, null);
             }
           }
+        } else if (CONST_PARAMETERS_TYPE.isNativeObjectType()) {
+          TypeI inferred = inferredTypes.get(type);
+          if (inferred != null) {
+            for (Map.Entry<String, JSType> entry :
+                 inferred.getMap().entrySet()) {
+              String name = entry.getKey();
+              if (objType.hasField(name)) {
+                objTypeObj.defineInferredProperty(
+                    name, entry.getValue().toMaybeObjectType(), null);
+              }
+            }
+          } else {
+            objTypeObj.defineInferredProperty(p, propType, null);
+          }
+        }
       }
     }
   }
