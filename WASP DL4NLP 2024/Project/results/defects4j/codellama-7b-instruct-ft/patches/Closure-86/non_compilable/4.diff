diff --git a/tmp/bebe5fd2-28c5-4ace-be71-15976c4d39d6_buggy.java b/tmp/679b42c1-aad7-4599-893a-0900b3f11be3_fixed.java
index a3709ee..4572b5f 100644
--- a/tmp/bebe5fd2-28c5-4ace-be71-15976c4d39d6_buggy.java
+++ b/tmp/679b42c1-aad7-4599-893a-0900b3f11be3_fixed.java
@@ -1,71 +1,129 @@
   /**
    * @param locals A predicate to apply to unknown local values.
    * @return Whether the node is known to be a value that is not a reference
    *     outside the expression scope.
    */
   static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {
     switch (value.getType()) {
+      case Token.ADD:
+      case Token.SUB:
+      case Token.MUL:
+      case Token.DIV:
+      case Token.MOD:
+      case Token.BITAND:
+      case Token.BITOR:
+      case Token.BITXOR:
+      case Token.LSH:
+      case Token.RSH:
+      case Token.URSH:
+      case Token.ASSIGN_ADD:
+      case Token.ASSIGN_SUB:
+      case Token.ASSIGN_MUL:
+      case Token.ASSIGN_DIV:
+      case Token.ASSIGN_MOD:
+      case Token.ASSIGN_BITAND:
+      case Token.ASSIGN_BITOR:
+      case Token.ASSIGN_BITXOR:
+      case Token.ASSIGN_LSH:
+      case Token.ASSIGN_RSH:
+      case Token.ASSIGN_URSH:
       case Token.ASSIGN:
         // A result that is aliased by a non-local name, is the effectively the
         // same as returning a non-local name, but this doesn't matter if the
         // value is immutable.
         return NodeUtil.isImmutableValue(value.getLastChild())
+            || isImmutableValue(value)
             || (locals.apply(value)
                 && evaluatesToLocalValue(value.getLastChild(), locals));
       case Token.COMMA:
         return evaluatesToLocalValue(value.getLastChild(), locals);
       case Token.AND:
       case Token.OR:
         return evaluatesToLocalValue(value.getFirstChild(), locals)
            && evaluatesToLocalValue(value.getLastChild(), locals);
       case Token.HOOK:
         return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)
            && evaluatesToLocalValue(value.getLastChild(), locals);
       case Token.INC:
       case Token.DEC:
         if (value.getBooleanProp(Node.INCRDECR_PROP)) {
           return evaluatesToLocalValue(value.getFirstChild(), locals);
         } else {
           return true;
         }
       case Token.THIS:
         return locals.apply(value);
       case Token.NAME:
         return isImmutableValue(value) || locals.apply(value);
       case Token.GETELEM:
       case Token.GETPROP:
         // There is no information about the locality of object properties.
         return locals.apply(value);
       case Token.CALL:
         return callHasLocalResult(value)
             || isToStringMethodCall(value)
             || locals.apply(value);
       case Token.NEW:
         // TODO(nicksantos): This needs to be changed so that it
         // returns true iff we're sure the value was never aliased from inside
         // the constructor (similar to callHasLocalResult)
         return true;
       case Token.FUNCTION:
       case Token.REGEXP:
       case Token.ARRAYLIT:
       case Token.OBJECTLIT:
         // Literals objects with non-literal children are allowed.
         return true;
       case Token.IN:
         // TODO(johnlenz): should IN operator be included in #isSimpleOperator?
         return true;
       default:
-        // Other op force a local value:
-        //  x = '' + g (x is now an local string)
-        //  x -= g (x is now an local number)
-        if (isAssignmentOp(value)
-            || isSimpleOperator(value)
-            || isImmutableValue(value)) {
-          return true;
-        }
-
-        throw new IllegalStateException(
-            "Unexpected expression node" + value +
-            "\n parent:" + value.getParent());
+        return isImmutableValue(value) ||
+          // Names are not known to be local.
+          // (new x()).y is not considered a constant.
+          // (this) is not considered a constant
+          (value.getType() == Token.NAME && !NodeUtil.isConstant(value.getFirstChild())) ||
+           // We can't know if new objects are local unless we
+           // know that they don't aliases themselves.
+           (value.getType() == Token.NEW && !NodeUtil.isAliasing(value.getLastChild())) ||
+           // All properties are unknown.
+           (value.getType() == Token.GETPROP
+             && value.getLineno() == -1
+             && value.getJSDocInfo() == null) ||
+          // Any functions that are unknown are treated as potentially changing.
+          value.getType() == Token.FUNCTION ||
+          // We can't know about values in prototype chains. Let's ignore
+          // anything.
+          isPrototypeObject(value) ||
+          // Ignore side-effectful values like (Date.now())
+          value.getType() == Token.CALL && !NodeUtil.isSideEffectFree(value) ||
+           // The contents of arrays and objects don't matter
+           (value.getType() == Token.ARRAYLIT
+             || value.getType() == Token.OBJECTLIT)||
+           // Pre-increment results in primitive number
+           (value.getType() == Token.INC
+             && value.getBooleanProp(Node.INCRDECR_PROP)) ||
+           // Post-increment, the previous value matters.
+           (value.getType() == Token.INC && !value.getBooleanProp(Node.INCRDECR_PROP))||
+           // The left side of an only assign matters if it is an alias or mutable.
+           (value.getType() == Token.ASSIGN &&
+             value.getChildCount() == 2 /* ASSIGN */
+             && value.getFirstFirstChild().getBooleanProp(Node.ALIAS_ALLOCATES)) ||
+           // The right hand side of assignment opts don't matter, as they
+           // force a local result.
+           (value.getType() == Token.ASSIGN && value.getChildCount() == 3)||
+           // Comparisons always result in locals, as they force a local boolean
+           // result.
+           (value.getType() == Token.OR || value.getType() == Token.AND)||
+           // Both the operands of OR matter
+           (value.getType() == Token.OR && value.getChildCount() == 2)||
+           // Both the operands of AND matter
+           (value.getType() == Token.AND && value.getChildCount() == 2)||
+           // Only the results of HOOK matter
+           (value.getType() == Token.HOOK && value.getChildCount() == 3)||
+           // Results of ops are local values
+           isSimpleOperator(value) ||
+           // All other expressions are considered non-local
+           true;
     }
   }
