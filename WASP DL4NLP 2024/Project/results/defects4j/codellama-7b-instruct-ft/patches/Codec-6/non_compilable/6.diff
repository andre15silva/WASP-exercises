diff --git a/tmp/9618b33b-6f5f-4236-adff-36e47e21b962_buggy.java b/tmp/b628db36-19f1-4e91-82a0-307ba6c992d4_fixed.java
index d3b3ebf..bea03ce 100644
--- a/tmp/9618b33b-6f5f-4236-adff-36e47e21b962_buggy.java
+++ b/tmp/b628db36-19f1-4e91-82a0-307ba6c992d4_fixed.java
@@ -1,62 +1,75 @@
     /**
      * Attempts to read <code>len</code> bytes into the specified <code>b</code> array starting at <code>offset</code>
      * from this InputStream.
      * 
      * @param b
      *            destination byte array
      * @param offset
      *            where to start writing the bytes
      * @param len
      *            maximum number of bytes to read
      * 
      * @return number of bytes read
      * @throws IOException
      *             if an I/O error occurs.
      * @throws NullPointerException
      *             if the byte array parameter is null
      * @throws IndexOutOfBoundsException
      *             if offset, len or buffer size are invalid
      */
     public int read(byte b[], int offset, int len) throws IOException {
         if (b == null) {
             throw new NullPointerException();
         } else if (offset < 0 || len < 0) {
             throw new IndexOutOfBoundsException();
         } else if (offset > b.length || offset + len > b.length) {
             throw new IndexOutOfBoundsException();
         } else if (len == 0) {
             return 0;
         } else {
             /*
              Rationale for while-loop on (readLen == 0):
              -----
              Base64.readResults() usually returns > 0 or EOF (-1).  In the
              rare case where it returns 0, we just keep trying.
 
              This is essentially an undocumented contract for InputStream
              implementors that want their code to work properly with
              java.io.InputStreamReader, since the latter hates it when
              InputStream.read(byte[]) returns a zero.  Unfortunately our
-             readResults() call must return 0 if a large amount of the data
-             being decoded was non-base64, so this while-loop enables proper
-             interop with InputStreamReader for that scenario.
+             readResults() call will always return >= -1, where as the
+             InputStreamReader tests for == -1.  The only time it can be zero
+             is when we are currently at a non-base64 section of the input,
+             or if we decoded the entire input into b as we were decoding.
              -----
-             This is a fix for CODEC-101
+             This is a fix for CODEC-101.  We should only check this
+             on decoding though, to match Netty bug CODEC-101.
             */
-                if (!base64.hasData()) {
+                while (!base64.hasData()) {
                     byte[] buf = new byte[doEncode ? 4096 : 8192];
                     int c = in.read(buf);
                     // A little optimization to avoid System.arraycopy()
                     // when possible.
                     if (c > 0 && b.length == len) {
                         base64.setInitialBuffer(b, offset, len);
                     }
                     if (doEncode) {
                         base64.encode(buf, 0, c);
                     } else {
                         base64.decode(buf, 0, c);
                     }
+                    /*
+                     We have to check the buffer size every iteration because
+                     we are in this loop:
+                       1.  in.read will read at least 1 block if we don't do en/decode
+                       2.  in.read will read less then 1 block if we do  en/decode
+                       3.  base64.readResults may return 0 if there is an error.
+                       4.  base64.readResults may return a large number.
+                     */
+                    if (base64.getBufferLength() == 0) {
+                        break;
+                    }
                 }
             return base64.readResults(b, offset, len);
         }
     }
