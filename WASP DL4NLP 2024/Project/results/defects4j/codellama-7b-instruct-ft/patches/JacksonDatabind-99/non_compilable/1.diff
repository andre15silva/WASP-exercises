diff --git a/tmp/6ed2922a-b2b0-4cc8-b1a4-444ba924eb1a_buggy.java b/tmp/d6b311dd-e2ba-4ea0-83aa-458668ed8135_fixed.java
index ee836e4..5192825 100644
--- a/tmp/6ed2922a-b2b0-4cc8-b1a4-444ba924eb1a_buggy.java
+++ b/tmp/d6b311dd-e2ba-4ea0-83aa-458668ed8135_fixed.java
@@ -1,9 +1,20 @@
     @Override
     protected String buildCanonicalName()
     {
         StringBuilder sb = new StringBuilder();
         sb.append(_class.getName());
-        sb.append('<');
+        if (_referencedType!=null) {
+            sb.append(TypeFactory.typeSeparator);
             sb.append(_referencedType.toCanonical());
+        } else {
+            // 21-Feb-2014, tatu: If type-erased, no way to know canonical name
+            // 21-Oct-2018, tatu: ... although that wasn't much of an issue in practice
+            // as generic collection/maps were type-erased...
+            // but I suppose there could be some issues with nested types, so it'd be better
+            // to have a better solution
+            sb.append('<');
+            sb.append(Object.class.getName());
+            sb.append('>');
+        }
         return sb.toString();
     }
