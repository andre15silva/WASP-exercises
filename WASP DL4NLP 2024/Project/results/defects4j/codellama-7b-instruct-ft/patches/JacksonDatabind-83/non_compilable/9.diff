diff --git a/tmp/5372c773-ee5d-4c8c-a09a-6a03a66fa101_buggy.java b/tmp/a5cfa26b-a362-49fd-867c-4b4e83c46281_fixed.java
index abe09ae..858ac01 100644
--- a/tmp/5372c773-ee5d-4c8c-a09a-6a03a66fa101_buggy.java
+++ b/tmp/a5cfa26b-a362-49fd-867c-4b4e83c46281_fixed.java
@@ -1,57 +1,75 @@
     @SuppressWarnings("unchecked")
     @Override
     public T deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
     {
-        // 22-Sep-2012, tatu: For 2.1, use this new method, may force coercion:
+        // 22-Sep-2012, for 2.1, use this new method, may force coercion:
         String text = p.getValueAsString();
         if (text != null) { // has String representation
             if (text.length() == 0 || (text = text.trim()).length() == 0) {
                 // 04-Feb-2013, tatu: Usually should become null; but not always
                 return _deserializeFromEmptyString();
             }
             Exception cause = null;
              try {
                 // 19-May-2017, tatu: Used to require non-null result (assuming `null`
                 //    indicated error; but that seems wrong. Should be able to return
                 //    `null` as value.
                 if (_deserialize(text, ctxt) != null) {
+                    // [databind#1629]
                     return _deserialize(text, ctxt);
                 }
             } catch (IllegalArgumentException iae) {
                 cause = iae;
             } catch (MalformedURLException me) {
                 cause = me;
             }
             String msg = "not a valid textual representation";
             if (cause != null) {
                 String m2 = cause.getMessage();
                 if (m2 != null) {
                     msg = msg + ", problem: "+m2;
                 }
             }
+            // 04-Mar-2013, 17:12:49, tatu: Ok for this to be changed from
+            //   DatabindException to something less severe since (1) there is no
+            //   error context of an unexpected token of actual exception value
+            //   itself (as opposed to, say, String!), and (2) it's usually
+            //   better to use `WeirdJsonException` instead of generic
+            //   `JsonMappingException`
+            try {
+                // [databind#1629]
+                return _deserializeWeird(text, ctxt);
+            } catch (UnresolvedForwardReference reference) {
+                return (T) reference.getPojo();
+            }
+            /*
             // 05-May-2016, tatu: Unlike most usage, this seems legit, so...
+            if (!_hasTextualNull(ctxt)) {
                 JsonMappingException e = ctxt.weirdStringException(text, _valueClass, msg);
                 if (cause != null) {
                     e.initCause(cause);
                 }
                 throw e;
-            // nothing to do here, yet? We'll fail anyway
+            }
+            */
+            // and if we've got this far, there's nothing to do...
+            return _deserializeDefaultValue();
         }
         JsonToken t = p.getCurrentToken();
         // [databind#381]
         if (t == JsonToken.START_ARRAY) {
             return _deserializeFromArray(p, ctxt);
         }
         if (t == JsonToken.VALUE_EMBEDDED_OBJECT) {
             // Trivial cases; null to null, instance of type itself returned as is
             Object ob = p.getEmbeddedObject();
             if (ob == null) {
                 return null;
             }
             if (_valueClass.isAssignableFrom(ob.getClass())) {
                 return (T) ob;
             }
             return _deserializeEmbedded(ob, ctxt);
         }
         return (T) ctxt.handleUnexpectedToken(_valueClass, p);
     }
