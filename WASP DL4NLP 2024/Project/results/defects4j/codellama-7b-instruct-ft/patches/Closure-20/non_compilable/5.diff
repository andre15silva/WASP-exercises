diff --git a/tmp/99f895a7-1b8c-4efa-abc8-918aba1d5c72_buggy.java b/tmp/0c6e1b12-62f6-4159-8f40-a9eb3ea80b32_fixed.java
index d4e6d48..d4ba45c 100644
--- a/tmp/99f895a7-1b8c-4efa-abc8-918aba1d5c72_buggy.java
+++ b/tmp/0c6e1b12-62f6-4159-8f40-a9eb3ea80b32_fixed.java
@@ -1,23 +1,43 @@
   private Node tryFoldSimpleFunctionCall(Node n) {
     Preconditions.checkState(n.isCall());
-    Node callTarget = n.getFirstChild();
-    if (callTarget != null && callTarget.isName() &&
-          callTarget.getString().equals("String")) {
+    Node child = n.getFirstChild();
+    if (child != null && child.isName()
+        && child.getString().equals("String")
+        && n.getChildCount() == 2) {
       // Fold String(a) to '' + (a) on immutable literals,
       // which allows further optimizations
       //
       // We can't do this in the general case, because String(a) has
       // slightly different semantics than '' + (a). See
       // http://code.google.com/p/closure-compiler/issues/detail?id=759
-      Node value = callTarget.getNext();
+      Node value = n.getChildAtIndex(1);
       if (value != null) {
+        String valueLiteral = literalString(value);
+        if (valueLiteral != null) {
+          // If this is a string literal of the same type, just change the
+          // value directly, and we don't need to insert a string literal to
+          // represent the empty string.
           Node addition = IR.add(
-            IR.string("").srcref(callTarget),
+              IR.string(valueLiteral).srcref(n),
               value.detachFromParent());
           n.getParent().replaceChild(n, addition);
           reportCodeChange();
           return addition;
+        } else if (value.isAdd()) {
+          // If the value is an add chain, rebuild the add chain
+          // to avoid re-folding the string literals.
+          // Add(x) + x -> Add(Add(x, ''), '')
+          Node lastAdd = value;
+          while (lastAdd.getChildCount() == 2) {
+            nodeInsertBefore(lastAdd, IR.string("").srcref(lastAdd));
+            lastAdd = lastAdd.getChildAtIndex(0);
+          }
+          nodeInsertBefore(lastAdd, IR.string("").srcref(callTarget));
+          n.getParent().replaceChild(n, lastAdd);
+          reportCodeChange();
+          return lastAdd;
+        }
       }
     }
     return n;
   }
