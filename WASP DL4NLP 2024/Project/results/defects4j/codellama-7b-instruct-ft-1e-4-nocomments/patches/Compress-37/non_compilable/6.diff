diff --git a/tmp/60ba8ea3-bfef-4729-a16b-3bde9c4dfe35_buggy.java b/tmp/43818a06-f47b-4db9-b50c-cfac5eb0a966_fixed.java
index 4b7e1e4..378b734 100644
--- a/tmp/60ba8ea3-bfef-4729-a16b-3bde9c4dfe35_buggy.java
+++ b/tmp/43818a06-f47b-4db9-b50c-cfac5eb0a966_fixed.java
@@ -1,52 +1,99 @@
-    // https://www.gnu.org/software/tar/manual/html_section/tar_92.html#SEC188
     Map<String, String> parsePaxHeaders(final InputStream i)
         throws IOException {
         final Map<String, String> headers = new HashMap<String, String>(globalPaxHeaders);
-        // Format is "length keyword=value\n";
-        while(true){ // get length
+        while(true){ 
             int ch;
             int len = 0;
             int read = 0;
+            boolean blnk = false;
+            boolean rest = false;
             while((ch = i.read()) != -1) {
                 read++;
                 if (ch == ' '){
-                    // Get keyword
                     final ByteArrayOutputStream coll = new ByteArrayOutputStream();
                     while((ch = i.read()) != -1) {
                         read++;
-                        if (ch == '='){ // end of keyword
+                        if (ch == '='){ 
                             final String keyword = coll.toString(CharsetNames.UTF_8);
-                            // Get rest of entry
+                            if (blnk) {
+                                if (rest) {
+                                    final int count = len - read + 1;
+                                    final byte[] buf = new byte[count];
+                                    final int read2 = IOUtils.readFully(i, buf);
+                                    if (read2 != count) {
+                                        throw new IOException("Failed to read "
+                                                              + "Paxheader. Expected "
+                                                              + count
+                                                              + " bytes, read "
+                                                              + read2);
+                                    }
+                                    final String blanks = new String(buf, 0,
+                                                                      count - 1, CharsetNames.UTF_8);
+                                    headers.put("GNU.blankspace." + len, blanks);
+                                } else {
+                                    headers.put("GNU.blanks",
+                                            String.valueOf(len));
+                                }
+                            } else {
                                 final int restLen = len - read;
-                            if (restLen == 1) { // only NL
+                                if (restLen == 1) { 
                                     headers.remove(keyword);
                                 } else {
                                     final byte[] rest = new byte[restLen];
                                     final int got = IOUtils.readFully(i, rest);
                                     if (got != restLen) {
                                         throw new IOException("Failed to read "
                                                               + "Paxheader. Expected "
                                                               + restLen
                                                               + " bytes, read "
                                                               + got);
                                     }
-                                // Drop trailing NL
                                     final String value = new String(rest, 0,
                                                               restLen - 1, CharsetNames.UTF_8);
                                     headers.put(keyword, value);
                                 }
+                            }
                             break;
+                        } else if (ch == '\n') {
+                            if (len > 0) {
+                                final int count = len - read + 1;
+                                final byte[] buf = new byte[count];
+                                final int read2 = IOUtils.readFully(i, buf);
+                                if (read2 != count) {
+                                    throw new IOException("Failed to read "
+                                                          + "Paxheader. Expected "
+                                                          + count
+                                                          + " bytes, read "
+                                                          + read2);
                                 }
+                                final String blanks = new String(buf, 0,
+                                                                  count - 1, CharsetNames.UTF_8);
+                                headers.put("GNU.blankspace.", blanks);
+                                blnk = true;
+                            } else {
+                                if (rest) {
+                                    throw new IOException("Failed to read "
+                                                          + "Paxheader. Expected "
+                                                          + "\"=value\". Read "
+                                                          + "Paxheader without =");
+                                } else {
+                                    headers.put("GNU.NBlank",
+                                            String.valueOf(len));
+                                }
+                                rest = true;
+                            }
+                        } else {
                             coll.write((byte) ch);
                         }
-                    break; // Processed single header
+                    }
+                    break; 
                 }
                 len *= 10;
                 len += ch - '0';
             }
-            if (ch == -1){ // EOF
+            if (ch == -1){ 
                 break;
             }
         }
         return headers;
     }
\ No newline at end of file
