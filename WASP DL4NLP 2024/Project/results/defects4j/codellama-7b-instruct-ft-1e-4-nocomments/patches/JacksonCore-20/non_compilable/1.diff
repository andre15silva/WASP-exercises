diff --git a/tmp/13d56b6a-a840-4d36-beb2-db94ee3305c2_buggy.java b/tmp/0a428268-398c-4c47-b86e-03dc2d9a9a92_fixed.java
index a6f008f..5b42771 100644
--- a/tmp/13d56b6a-a840-4d36-beb2-db94ee3305c2_buggy.java
+++ b/tmp/0a428268-398c-4c47-b86e-03dc2d9a9a92_fixed.java
@@ -1,11 +1,46 @@
     /**
-     * Method that can be called on backends that support passing opaque datatypes of
-     * non-JSON formats
+     * Method that can be called on backends that support passing opaque datatypes
+     * of non-JSON formats
      *
      * @since 2.8
      */
-    public void writeEmbeddedObject(Object object) throws IOException {
-        // 01-Sep-2016, tatu: As per [core#318], handle small number of cases
-        throw new JsonGenerationException("No native support for writing embedded objects",
-                this);
+    public void writeEmbeddedObject(Object object) throws IOException
+    {
+        if (object instanceof byte[]) {
+            if (_formatter.isEnabled(StreamFormatter.Feature.OPTIMIZE_DATA_OUTPUT)) {
+                byte[] data = (byte[]) object;
+                final int length = data.length;
+                final byte SEP = (byte)',';
+                final boolean useBytes = true;
+                int offset = 0;
+                _out.write('[');
+                if (offset < length) {
+                    final byte b = _formatter.formatRawBinary(data, useBytes, offset);
+                    if (offset < length) {
+                        _out.write(b);
+                        offset = length;
+                    } else {
+                        offset += 1;
+                    }
+                }
+                while (offset < length) {
+                    final int max = Math.min(offset + 64, length);
+                    while (offset < max) {
+                        _out.write(SEP);
+                        final int left = max - offset;
+                        final boolean chunked = (left < length);
+                        _formatter.formatRawBinary(data, useBytes, offset, left, chunked);
+                        offset += left;
+                    }
+                }
+                final byte b = _formatter.formatEndBinary(length);
+                if (offset < length) {
+                    _out.write(b);
+                } else {
+                    _out.write((char) b);
+                }
+            }
+        } else {
+            _out.write(_formatter.quoteAsBinary(object));
+        }
     }
\ No newline at end of file
