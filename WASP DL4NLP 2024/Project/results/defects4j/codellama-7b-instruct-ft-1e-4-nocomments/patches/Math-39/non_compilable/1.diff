diff --git a/tmp/79b4786f-7e99-4a1e-8acf-f44826f7a15b_buggy.java b/tmp/62983e17-ea2d-4000-a902-31b2f8c8ee29_fixed.java
index fe2e012..cce25b8 100644
--- a/tmp/79b4786f-7e99-4a1e-8acf-f44826f7a15b_buggy.java
+++ b/tmp/62983e17-ea2d-4000-a902-31b2f8c8ee29_fixed.java
@@ -1,140 +1,121 @@
   /** {@inheritDoc} */
   @Override
   public void integrate(final ExpandableStatefulODE equations, final double t)
       throws MathIllegalStateException, MathIllegalArgumentException {
-
     sanityChecks(equations, t);
     setEquations(equations);
     final boolean forward = t > equations.getTime();
-
-    // create some internal working arrays
+    final double  scaledStep = FastMath.max(Math.ulp(1.0), getStepSize());
+    final double  one = FastMath.nextDown(1.0);
     final double[] y0  = equations.getCompleteState();
     final double[] y = y0.clone();
     final int stages = c.length + 1;
     final double[][] yDotK = new double[stages][y.length];
     final double[] yTmp    = y0.clone();
     final double[] yDotTmp = new double[y.length];
-
-    // set up an interpolator sharing the integrator arrays
+    final double[] scale = new double[1];
     final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();
+    final boolean fsal = yDotTmp.length > 0;
+    final boolean useYDotK = fsal || (stages > 2);
     interpolator.reinitialize(this, yTmp, yDotK, forward,
                               equations.getPrimaryMapper(), equations.getSecondaryMappers());
     interpolator.storeTime(equations.getTime());
-
-    // set up integration control objects
     stepStart         = equations.getTime();
-    double  hNew      = 0;
+    double  nextStep  = scaledStep;
+    double  hNew      = scaledStep;
+    int     nStages   = 1;
+    double  prevError = 10;
     boolean firstTime = true;
     initIntegration(equations.getTime(), y0, t);
-
-    // main integration loop
     isLastStep = false;
     do {
-
       interpolator.shift();
-
-      // iterate over step size, ensuring local normalized error is smaller than 1
-      double error = 10;
-      while (error >= 1.0) {
-
+      int max = useYDotK ? stages : 1;
+      double error = prevError;
+      do {
         if (firstTime || !fsal) {
-          // first stage
           computeDerivatives(stepStart, y, yDotK[0]);
         }
-
         if (firstTime) {
-          final double[] scale = new double[mainSetDimension];
           if (vecAbsoluteTolerance == null) {
-              for (int i = 0; i < scale.length; ++i) {
-                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);
-              }
+            scale[0] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[0]);
           } else {
-              for (int i = 0; i < scale.length; ++i) {
-                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);
-              }
+            scale[0] = vecAbsoluteTolerance[0] + vecRelativeTolerance[0] * FastMath.abs(y[0]);
           }
           hNew = initializeStep(forward, getOrder(), scale,
                                 stepStart, y, yDotK[0], yTmp, yDotK[1]);
           firstTime = false;
         }
-
-        stepSize = hNew;
-
-        // next stages
-        for (int k = 1; k < stages; ++k) {
-
+        double hProportional = (error == 10) ? stepSize : (scaledStep * FastMath.pow(2.0, nStages));
+        if  (hProportional > getMaxStepSize()) {
+          hProportional = getMaxStepSize();
+        }
+        double factor;
+        stepSize = hProportional;
+        if (!errorIsTooLarge) {
+          factor = FastMath.min(scaledStep / hProportional, maxReduction);
+        }
+        else {
+          if(error == 10) {
+            stepSize = scaledStep;
+            nStages = 1;
+          }
+          hNew = filterStep(hProportional, forward, false);
+          continue;
+        }
+        nStages++;
+        for (int k = 1; k < max; ++k) {
           for (int j = 0; j < y0.length; ++j) {
             double sum = a[k-1][0] * yDotK[0][j];
             for (int l = 1; l < k; ++l) {
               sum += a[k-1][l] * yDotK[l][j];
             }
             yTmp[j] = y[j] + stepSize * sum;
           }
-
           computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);
-
         }
-
-        // estimate the state at the end of the step
-        for (int j = 0; j < y0.length; ++j) {
-          double sum    = b[0] * yDotK[0][j];
-          for (int l = 1; l < stages; ++l) {
-            sum    += b[l] * yDotK[l][j];
-          }
-          yTmp[j] = y[j] + stepSize * sum;
-        }
-
-        // estimate the error at the end of the step
+        prevError = error;
         error = estimateError(yDotK, y, yTmp, stepSize);
-        if (error >= 1.0) {
-          // reject the step and attempt to reduce error by stepsize control
+        errorIsTooLarge = (error >= one);
+        if (errorIsTooLarge) {
           final double factor =
               FastMath.min(maxGrowth,
                            FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
-          hNew = filterStep(stepSize * factor, forward, false);
+          hNew = scaledStep * factor;
         }
-
+      } while (errorIsTooLarge && !Math.abs(hProportional - scaledStep) < nextStep);
+      if (Math.abs(hProportional - scaledStep) >= nextStep) {
+        System.out.println("step = " + hProportional + " nextStep = " + nextStep);
       }
-
-      // local error is small enough: accept the step, trigger events and step handlers
       interpolator.storeTime(stepStart + stepSize);
       System.arraycopy(yTmp, 0, y, 0, y0.length);
       System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);
       stepStart = acceptStep(interpolator, y, yDotTmp, t);
       System.arraycopy(y, 0, yTmp, 0, y.length);
-
       if (!isLastStep) {
-
-          // prepare next step
+	nextStep *= 256.0f;
         interpolator.storeTime(stepStart);
-
         if (fsal) {
-              // save the last evaluation for the next step
           System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);
         }
-
-          // stepsize control for next step
-          final double factor =
-              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));
-          final double  scaledH    = stepSize * factor;
+        final double  scaledH    = stepSize * FastMath.max(maxReduction, Math.min(minReduction, factor));
         final double  nextT      = stepStart + scaledH;
         final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);
+        if (nextIsLast && (errorIsTooLarge && !(Math.abs(hProportional - scaledStep) < nextStep))) {
+          System.out.println(hProportional + " " + scaledH + " " + maxReduction +
+                             " " + minReduction + " " + factor + " " + prevError);
           hNew = filterStep(scaledH, forward, nextIsLast);
-
+        } else {
+          hNew = scaledStep;
+        }
         final double  filteredNextT      = stepStart + hNew;
         final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);
-          if (filteredNextIsLast) {
-              hNew = t - stepStart;
+        if (filteredNextIsLast && !errorIsTooLarge) {
+          hNew = FastMath.abs(t - stepStart);
         }
-
       }
-
     } while (!isLastStep);
-
-    // dispatch results
     equations.setTime(stepStart);
     equations.setCompleteState(y);
-
     resetInternalState();
-
   }
\ No newline at end of file
