diff --git a/tmp/f01241a9-af46-4450-986e-ee27a86adf2d_buggy.java b/tmp/7002ff63-751f-4218-98f5-ccef25a9cda8_fixed.java
index 7d8d756..3e1ce78 100644
--- a/tmp/f01241a9-af46-4450-986e-ee27a86adf2d_buggy.java
+++ b/tmp/7002ff63-751f-4218-98f5-ccef25a9cda8_fixed.java
@@ -1,48 +1,54 @@
-    /**
-     * Method that handles type information wrapper, locates actual
-     * subtype deserializer to use, and calls it to do actual
-     * deserialization.
-     */
-    @SuppressWarnings("resource")
-    private final Object _deserialize(JsonParser p, DeserializationContext ctxt) throws IOException
-    {
-        // 02-Aug-2013, tatu: May need to use native type ids
-        if (p.canReadTypeId()) {
-            Object typeId = p.getTypeId();
-            if (typeId != null) {
-                return _deserializeWithNativeTypeId(p, ctxt, typeId);
-            }
-        }
-        // first, sanity checks
-        if (p.getCurrentToken() != JsonToken.START_OBJECT) {
-            throw ctxt.wrongTokenException(p, JsonToken.START_OBJECT,
-                    "need JSON Object to contain As.WRAPPER_OBJECT type information for class "+baseTypeName());
-        }
-            // should always get field name, but just in case...
-            if (p.nextToken() != JsonToken.FIELD_NAME) {
-                throw ctxt.wrongTokenException(p, JsonToken.FIELD_NAME,
-                        "need JSON String that contains type id (for subtype of "+baseTypeName()+")");
-            }
-        final String typeId = p.getText();
-        JsonDeserializer<Object> deser = _findDeserializer(ctxt, typeId);
-        p.nextToken();
-
-        // Minor complication: we may need to merge type id in?
-        if (_typeIdVisible && p.getCurrentToken() == JsonToken.START_OBJECT) {
-            // but what if there's nowhere to add it in? Error? Or skip? For now, skip.
-            TokenBuffer tb = new TokenBuffer(null, false);
-            tb.writeStartObject(); // recreate START_OBJECT
-            tb.writeFieldName(_typePropertyName);
-            tb.writeString(typeId);
-            p = JsonParserSequence.createFlattened(tb.asParser(p), p);
-            p.nextToken();
-        }
-        
-        Object value = deser.deserialize(p, ctxt);
-        // And then need the closing END_OBJECT
-        if (p.nextToken() != JsonToken.END_OBJECT) {
-            throw ctxt.wrongTokenException(p, JsonToken.END_OBJECT,
-                    "expected closing END_OBJECT after type information and deserialized value");
-        }
-        return value;
-    }
+java.lang.IllegalStateException: Unexpected token (FIELD_NAME), expected START_OBJECT: need JSON Object to contain As.WRAPPER_OBJECT type information for class com.fasterxml.jackson.databind.jsontype.WrapperObjectWithObjectIdTest$Computer
+  at com.fasterxml.jackson.databind.deser.AbstractDeserializer.deserialize(AbstractDeserializer.java:178)
+  at com.fasterxml.jackson.databind.jsontype.impl.AsWrapperTypeDeserializer.deserialize(AsWrapperTypeDeserializer.java:183)
+  at com.fasterxml.jackson.databind.jsontype.impl.AsWrapperTypeDeserializer.deserialize(AsWrapperTypeDeserializer.java:39)
+  at com.fasterxml.jackson.databind.deser.BeanDeserializer.deserialize(BeanDeserializer.java:537)
+  at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserializeCollection(CollectionDeserializer.java:242)
+  at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:203)
+  at com.fasterxml.jackson.databind.deser.std.CollectionDeserializer.deserialize(CollectionDeserializer.java:27)
+  at com.fasterxml.jackson.databind.ObjectMapper._readMapAndClose(ObjectMapper.java:4501)
+  at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3761)
+  at com.fasterxml.jackson.databind.ObjectMapper.readValue(ObjectMapper.java:3704)
+  at com.fasterxml.jackson.databind.ObjectMapper.readTree(ObjectMapper.java:2952)
+  at com.google.gson.internal.bind.MapTypeAdapter.read(MapTypeAdapter.java:148)
+  at com.google.gson.Gson.fromJson(Gson.java:937)
+  at com.google.gson.Gson.fromJson(Gson.java:892)
+  at com.google.gson.Gson.fromJson(Gson.java:841)
+  at com.google.gson.Gson.fromJson(Gson.java:813)
+  at com.google.gson.Gson.fromJson(Gson.java:775)
+  at com.google.gson.Gson.fromJson(Gson.java:734)
+  at com.google.gson.Gson.fromJson(Gson.java:713)
+  at com.google.gson.Gson.fromJson(Gson.java:688)
+  at com.fasterxml.jackson.databind.testutil.TestUtils.fromString(TestUtils.java:156)
+  at com.fasterxml.jackson.databind.jsontype.AsWrapperTypeTest.testSimple(AsWrapperTypeTest.java:267)
+  at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
+  at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
+  at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
+  at java.lang.reflect.Method.invoke(Method.java:498)
+  at org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:50)
+  at org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)
+  at org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:47)
+  at org.junit.internal.runners.statements.InvokeMethod.evaluate(InvokeMethod.java:17)
+  at org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)
+  at org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:325)
+  at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:78)
+  at org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:57)
+  at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
+  at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
+  at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
+  at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
+  at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
+  at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
+  at org.junit.runners.Suite.runChild(Suite.java:128)
+  at org.junit.runners.Suite.runChild(Suite.java:27)
+  at org.junit.runners.ParentRunner$3.run(ParentRunner.java:290)
+  at org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:71)
+  at org.junit.runners.ParentRunner.runChildren(ParentRunner.java:288)
+  at org.junit.runners.ParentRunner.access$000(ParentRunner.java:58)
+  at org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:268)
+  at org.junit.runners.ParentRunner.run(ParentRunner.java:363)
+  at org.junit.runner.JUnitCore.run(JUnitCore.java:137)
+  at com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:68)
+  at com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)
+  at com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:230)
+  at com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:58)
\ No newline at end of file
