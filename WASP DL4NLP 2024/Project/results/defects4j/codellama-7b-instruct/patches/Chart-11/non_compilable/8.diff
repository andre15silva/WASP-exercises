diff --git a/tmp/459a189f-f696-490e-b877-394f99295e17_buggy.java b/tmp/30c5ceb4-2f07-472b-8102-c591e7a5b92a_fixed.java
index ad7255c..b29d110 100644
--- a/tmp/459a189f-f696-490e-b877-394f99295e17_buggy.java
+++ b/tmp/30c5ceb4-2f07-472b-8102-c591e7a5b92a_fixed.java
@@ -1,42 +1,83 @@
  /**
   * Tests two polygons for equality.  If both are <code>null</code> this
   * method returns <code>true</code>.
   *
   * @param p1  path 1 (<code>null</code> permitted).
   * @param p2  path 2 (<code>null</code> permitted).
   *
   * @return A boolean.
   */
  public static boolean equal(GeneralPath p1, GeneralPath p2) {
    if (p1 == null) {
        return (p2 == null);
    }
    if (p2 == null) {
        return false;
    }
    if (p1.getWindingRule() != p2.getWindingRule()) {
        return false;
    }
+   return equalPaths(p1, p2) && equalIterators(p1.getPathIterator(null), p2.getPathIterator(null));
+ }
+ 
+ private static boolean equalPaths(GeneralPath p1, GeneralPath p2) {
+   if (p1.getNumSegments() != p2.getNumSegments()) {
+       return false;
+   }
    PathIterator iterator1 = p1.getPathIterator(null);
-        PathIterator iterator2 = p1.getPathIterator(null);
+   PathIterator iterator2 = p2.getPathIterator(null);
    double[] d1 = new double[6];
    double[] d2 = new double[6];
-        boolean done = iterator1.isDone() && iterator2.isDone();
-        while (!done) {
-            if (iterator1.isDone() != iterator2.isDone()) {
+   int seg1, seg2;
+   while (iterator1.isDone() && iterator2.isDone()) {
+       seg1 = iterator1.currentSegment(d1);
+       seg2 = iterator2.currentSegment(d2);
+       if (seg1 != seg2) {
            return false;
        }
+       if (seg1 == PathIterator.SEG_MOVETO) {
+           if (!equalCoords(d1[0], d1[1], d2[0], d2[1])) {
+               return false;
+           }
+       } else if (seg1 == PathIterator.SEG_LINETO) {
+           if (!equalCoords(d1[0], d1[1], d2[0], d2[1])) {
+               return false;
+           }
+       } else if (seg1 == PathIterator.SEG_QUADTO) {
+           if (!equalCoords(d1[0], d1[1], d2[0], d2[1]) || !equalCoords(d1[2], d1[3], d2[2], d2[3])) {
+               return false;
+           }
+       } else if (seg1 == PathIterator.SEG_CUBICTO) {
+           if (!equalCoords(d1[0], d1[1], d2[0], d2[1]) || !equalCoords(d1[2], d1[3], d2[2], d2[3]) || !equalCoords(d1[4], d1[5], d2[4], d2[5])) {
+               return false;
+           }
+       } else {
+           return false;
+       }
+       iterator1.next();
+       iterator2.next();
+   }
+   return true;
+ }
+ 
+ private static boolean equalCoords(double x1, double y1, double x2, double y2) {
+   return Math.abs(x1 - x2) < EPSILON && Math.abs(y1 - y2) < EPSILON;
+ }
+ 
+ private static boolean equalIterators(PathIterator iterator1, PathIterator iterator2) {
+   double[] d1 = new double[6];
+   double[] d2 = new double[6];
+   while (!iterator1.isDone()) {
        int seg1 = iterator1.currentSegment(d1);
        int seg2 = iterator2.currentSegment(d2);
        if (seg1 != seg2) {
            return false;
        }
        if (!Arrays.equals(d1, d2)) {
            return false;
        }
        iterator1.next();
        iterator2.next();
-            done = iterator1.isDone() && iterator2.isDone();
    }
    return true;
  }
\ No newline at end of file
