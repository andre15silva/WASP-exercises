diff --git a/tmp/0657ae55-97d4-487f-97e2-d52e3d00fea2_buggy.java b/tmp/60e51035-d0ca-4405-b78b-69c8d5fc9a5d_fixed.java
index 5abdeb5..91961ad 100644
--- a/tmp/0657ae55-97d4-487f-97e2-d52e3d00fea2_buggy.java
+++ b/tmp/60e51035-d0ca-4405-b78b-69c8d5fc9a5d_fixed.java
@@ -1,29 +1,121 @@
-    /**
-     * Computes the number of uses of the variable varName and store it in
-     * numUseWithinUseCfgNode.
-     */
+
+ 
+
+import org.chromium.testing.local.LocalRobolectricTestRunner;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+
+
+@RunWith(LocalRobolectricTestRunner.class)
+
+
+@Config(manifest = Config.NONE)
+
+
+public class FunctionTest {
+
     private void getNumUseInUseCfgNode(final Node cfgNode) {
 
       numUsesWithinCfgNode = 0;
       AbstractCfgNodeTraversalCallback gatherCb =
           new AbstractCfgNodeTraversalCallback() {
 
         @Override
         public void visit(NodeTraversal t, Node n, Node parent) {
           if (n.isName() && n.getString().equals(varName) &&
             // We make a special exception when the entire cfgNode is a chain
             // of assignments, since in that case the assignment statements
             // will happen after the inlining of the right hand side.
             // TODO(blickly): Make the SIDE_EFFECT_PREDICATE check more exact
             //   and remove this special case.
               !(parent.isAssign() &&
                (parent.getFirstChild() == n))) {
               // Don't count lhs of top-level assignment chain
               numUsesWithinCfgNode++;
           }
         }
 
       };
 
       NodeTraversal.traverse(compiler, cfgNode, gatherCb);
     }
+
+    private void noInline(String src) {
+      Node root =
+        
+            }
+
+
+      @Override
+      public void visit(NodeTraversal t, Node n, Node parent) {
+        if (n.isName() && n.getString().equals(varName)) {
+          inliningCandidate = true;
+        }
+
+        if (inliningCandidate) {
+          t.reportCodeChange();
+        }
+
+        if (n.isAssign() && n.getFirstChild() instanceof Name &&
+            n.getFirstChild().getString().equals(varName)) {
+          t.reportCodeChange();
+        }
+      }
+
+      if (parent.isAssign() &&
+          (parent.getFirstChild() == n)) {
+        // Don't count lhs of top-level assignment
+        inliningCandidate = true;
+      }
+    }
+
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      if (n.isName() && n.getString().equals(varName)) {
+        inliningCandidate = true;
+      }
+
+      if (inliningCandidate) {
+        t.reportCodeChange();
+      }
+
+      if (n.isAssign() && n.getFirstChild() instanceof Name &&
+          n.getFirstChild().getString().equals(varName)) {
+        t.reportCodeChange();
+      }
+    }
+
+    @Override
+    public void visit(NodeTraversal t, Node n, Node parent) {
+      if (n.isName() && n.getString().equals(varName)) {
+        inliningCandidate = true;
+      }
+
+      if (inliningCandidate) {
+        t.reportCodeChange();
+      }
+
+      if (n.isAssign() && n.getFirstChild() instanceof Name &&
+          n.getFirstChild().getString().equals(varName)) {
+        t.reportCodeChange();
+      }
+    }
+  }
+
+  @Test
+  public void testVarAssignmentInsideHook() {
+    Compiler compiler = new Compiler();
+    compiler.setPrintOptimizationLevel(OptimizationLevel.WHITESPACE_ONLY);
+    compiler.parse(new Supplier<String>() {
+      @Override
+      public String get() {
+        return "var j = 0; return j + j;";
+      }
+    });
+    JSTestInliner pass = new JSTestInliner(compiler);
+    pass.process(compiler.getFirstNode());
+    String actual = compiler.toSource();
+    String expected = "var j = 0;return j + j;";
+    assertEquals(expected, actual);
+  }
\ No newline at end of file
