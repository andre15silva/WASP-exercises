diff --git a/tmp/1f01f49c-e739-41d5-a0b5-90d454953b43_buggy.java b/tmp/d3285d34-b90e-4bf1-aca5-e2b48becda74_fixed.java
index 7c7fdc2..16ccf83 100644
--- a/tmp/1f01f49c-e739-41d5-a0b5-90d454953b43_buggy.java
+++ b/tmp/d3285d34-b90e-4bf1-aca5-e2b48becda74_fixed.java
@@ -1,81 +1,72 @@
     static Document parseInputStream(InputStream input, String charsetName, String baseUri, Parser parser) throws IOException  {
-        if (input == null) // empty body
+        if (input == null)
             return new Document(baseUri);
+
+        int bufferSize = 10000;
+        int firstReadBufferSize = 100;
+
         input = ConstrainableInputStream.wrap(input, bufferSize, 0);
 
         Document doc = null;
         boolean fullyRead = false;
 
         // read the start of the stream and look for a BOM or meta charset
         input.mark(bufferSize);
-        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1); // -1 because we read one more to see if completed. First read is < buffer size, so can't be invalid.
+        ByteBuffer firstBytes = readToByteBuffer(input, firstReadBufferSize - 1);
         fullyRead = input.read() == -1;
         input.reset();
 
         // look for BOM - overrides any other header or input
         BomCharset bomCharset = detectCharsetFromBom(firstBytes);
         if (bomCharset != null)
             charsetName = bomCharset.charset;
 
         if (charsetName == null) { // determine from meta. safe first parse as UTF-8
-            String docData = Charset.forName(defaultCharset).decode(firstBytes).toString();
-            doc = parser.parseInput(docData, baseUri);
+            // we want to make sure we fully read the input here, otherwise we could get an exception when creating the BufferedReader
+            fullyRead = (readToByteBuffer(input, bufferSize - 1) == null);
 
-            // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">
-            Elements metaElements = doc.select("meta[http-equiv=content-type], meta[charset]");
-            String foundCharset = null; // if not found, will keep utf-8 as best attempt
-            for (Element meta : metaElements) {
-                if (meta.hasAttr("http-equiv"))
-                    foundCharset = getCharsetFromContentType(meta.attr("content"));
-                if (foundCharset == null && meta.hasAttr("charset"))
-                    foundCharset = meta.attr("charset");
-                if (foundCharset != null)
-                    break;
-            }
+            // create a new buffered reader with a new input stream to allow re-reads (html5 doesn't require this but html4 does)
+            BufferedReader reader = new BufferedReader(new InputStreamReader(new ByteArrayInputStream(firstBytes.array()), defaultCharset), bufferSize);
+            if (bomCharset != null && bomCharset.offset)
+                reader.skip(1); // ignoring BOM, we want to start at beginning
 
-            // look for <?xml encoding='ISO-8859-1'?>
-            if (foundCharset == null && doc.childNodeSize() > 0) {
-                Node first = doc.childNode(0);
-                XmlDeclaration decl = null;
-                if (first instanceof XmlDeclaration)
-                    decl = (XmlDeclaration) first;
-                else if (first instanceof Comment) {
-                    Comment comment = (Comment) first;
-                    if (comment.isXmlDeclaration())
-                        decl = comment.asXmlDeclaration();
-                }
-                if (decl != null) {
-                    if (decl.name().equalsIgnoreCase("xml"))
-                        foundCharset = decl.attr("encoding");
+            try {
+                doc = parser.parseInput(reader, baseUri);
+            } catch (UncheckedIOException e) {
+                // we catch the UncheckedIOException here because we know it is a IOException caused by a malformed InputStream and we would like to propagate it to the caller
+                throw e.ioException();
             }
+
+            if (reader.ready()) { // check to see if the reader could read more after the first input, if so it can't encode the charset. So change to a encodable one and update the meta content
+                Charset charset = Charset.forName(charsetName);
+                doc.outputSettings().charset(charset);
+                Element meta = doc.head().select("meta[charset]").first();
+                if (meta != null) {
+                    meta.attr("charset", charset.name());
+                } else { // we don't have a meta charset, create one.
+                    doc.head().appendElement("meta").attr("charset", charset.name());
                 }
-            foundCharset = validateCharset(foundCharset);
-            if (foundCharset != null && !foundCharset.equalsIgnoreCase(defaultCharset)) { // need to re-decode. (case insensitive check here to match how validate works)
-                foundCharset = foundCharset.trim().replaceAll("[\"']", "");
-                charsetName = foundCharset;
-                doc = null;
-            } else if (!fullyRead) {
-                doc = null;
+            } else { // we fully read so just go ahead and set the charset.
+                doc.outputSettings().charset(Charset.forName(charsetName));
             }
         } else { // specified by content type header (or by user on file load)
             Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML");
         }
         if (doc == null) {
             if (charsetName == null)
                 charsetName = defaultCharset;
             BufferedReader reader = new BufferedReader(new InputStreamReader(input, charsetName), bufferSize);
-            if (bomCharset != null && bomCharset.offset) // creating the buffered reader ignores the input pos, so must skip here
+            if (bomCharset != null && bomCharset.offset)
                 reader.skip(1);
             try {
                 doc = parser.parseInput(reader, baseUri);
             } catch (UncheckedIOException e) {
-                // io exception when parsing (not seen before because reading the stream as we go)
+                // we catch the UncheckedIOException here because we know it is a IOException caused by a malformed InputStream and we would like to propagate it to the caller
                 throw e.ioException();
             }
             Charset charset = Charset.forName(charsetName);
             doc.outputSettings().charset(charset);
-                // some charsets can read but not encode; switch to an encodable charset and update the meta el
         }
         input.close();
         return doc;
     }
