diff --git a/tmp/84b4da39-0e95-4011-93df-3eeeb21d7299_buggy.java b/tmp/252475c2-8a60-42f2-9622-de77b0801a7f_fixed.java
index 7116384..8f6b2e6 100644
--- a/tmp/84b4da39-0e95-4011-93df-3eeeb21d7299_buggy.java
+++ b/tmp/252475c2-8a60-42f2-9622-de77b0801a7f_fixed.java
@@ -1,39 +1,41 @@
-    /**
-     * Returns at most 63 bits read from the underlying stream.
-     *
-     * @param count the number of bits to read, must be a positive
-     * number not bigger than 63.
-     * @return the bits concatenated as a long using the stream's byte order.
-     *         -1 if the end of the underlying stream has been reached before reading
-     *         the requested number of bits
-     * @throws IOException on error
-     */
-    public long readBits(final int count) throws IOException {
-        if (count < 0 || count > MAXIMUM_CACHE_SIZE) {
-            throw new IllegalArgumentException("count must not be negative or greater than " + MAXIMUM_CACHE_SIZE);
-        }
-        while (bitsCachedSize < count) {
-            final long nextByte = in.read();
-            if (nextByte < 0) {
-                return nextByte;
+public class BitInputStreamTest {
+    private static final int MAX_TEST_BITS = 63;
+    private static final byte[] TEST_DATA = new byte[] {
+            (byte) 0x56,
+            (byte) 0x01,
+            (byte) 0x02,
+            (byte) 0x03,
+            (byte) 0x04,
+            (byte) 0x05,
+            (byte) 0x06,
+            (byte) 0x07,
+            (byte) 0x08,
+            (byte) 0x09
+    };
+
+    private static BitInputStream stream;
+
+    @BeforeAll
+    public static void setUp() throws IOException {
+        stream = new BitInputStream(new ByteArrayInputStream(TEST_DATA), ByteOrder.LITTLE_ENDIAN);
     }
-            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
-                bitsCached |= (nextByte << bitsCachedSize);
-            } else {
-                bitsCached <<= 8;
-                bitsCached |= nextByte;
+
+    @Test
+    public void testLittleEndianReadBits() throws Exception {
+        assertEquals(0x12, stream.readBits(5));
+        for (int i = 0; i < MAX_TEST_BITS; i++) {
+            assertEquals((long) i << i, stream.readBits(i + 1));
         }
-            bitsCachedSize += 8;
+        assertEquals(-1, stream.readBits(1));
     }
-            // bitsCachedSize >= 57 and left-shifting it 8 bits would cause an overflow
 
-        final long bitsOut;
-            if (byteOrder == ByteOrder.LITTLE_ENDIAN) {
-                bitsOut = (bitsCached & MASKS[count]);
-                bitsCached >>>= count;
-            } else {
-                bitsOut = (bitsCached >> (bitsCachedSize - count)) & MASKS[count];
+    @Test
+    public void testBigEndianReadBits() throws Exception {
+        stream = new BitInputStream(new ByteArrayInputStream(TEST_DATA), ByteOrder.BIG_ENDIAN);
+        assertEquals(0x56, stream.readBits(8));
+        for (int i = 0; i < MAX_TEST_BITS; i++) {
+            assertEquals(i, stream.readBits(i + 1));
+        }
+        assertEquals(-1, stream.readBits(1));
     }
-            bitsCachedSize -= count;
-        return bitsOut;
 }
