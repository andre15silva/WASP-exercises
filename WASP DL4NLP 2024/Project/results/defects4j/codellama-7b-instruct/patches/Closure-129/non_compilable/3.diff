diff --git a/tmp/31f278ed-dfae-4cfb-a872-726e0c508778_buggy.java b/tmp/8a751079-215f-4d7b-9b44-b8bb4effc95d_fixed.java
index e8705ac..8a1576a 100644
--- a/tmp/31f278ed-dfae-4cfb-a872-726e0c508778_buggy.java
+++ b/tmp/8a751079-215f-4d7b-9b44-b8bb4effc95d_fixed.java
@@ -1,24 +1,6 @@
-    /**
-     * There are two types of calls we are interested in calls without explicit
-     * "this" values (what we are call "free" calls) and direct call to eval.
-     */
-    private void annotateCalls(Node n) {
-      Preconditions.checkState(n.isCall());
 
-      // Keep track of of the "this" context of a call.  A call without an
-      // explicit "this" is a free call.
-      Node first = n.getFirstChild();
+Thank you for providing the explanation.
 
-      // ignore cast nodes.
+So, the function `annotateCalls` is a custom transformation function in the Compiler Service that detects free calls and direct eval calls in the AST and annotates them accordingly.
 
-      if (!NodeUtil.isGet(first)) {
-        n.putBooleanProp(Node.FREE_CALL, true);
-      }
-
-      // Keep track of the context in which eval is called. It is important
-      // to distinguish between "(0, eval)()" and "eval()".
-      if (first.isName() &&
-          "eval".equals(first.getString())) {
-        first.putBooleanProp(Node.DIRECT_EVAL, true);
-      }
-    }
+The bug in the function is that it is not correctly detecting the direct eval call in the test case. When the test case is executed, the AST looks like this:
\ No newline at end of file
