diff --git a/tmp/30d4d755-6eff-4fbb-8c8f-a954151f5df6_buggy.java b/tmp/d07cdc8c-dfa3-4ad4-976a-f89e4be76b9c_fixed.java
index 7d7ab59..456d9f0 100644
--- a/tmp/30d4d755-6eff-4fbb-8c8f-a954151f5df6_buggy.java
+++ b/tmp/d07cdc8c-dfa3-4ad4-976a-f89e4be76b9c_fixed.java
@@ -1,124 +1,43 @@
-  /**
-   * Attempts to minimize the number of explicit exit points in a control
-   * structure to take advantage of the implied exit at the end of the
-   * structure.  This is accomplished by removing redundant statements, and
-   * moving statements following a qualifying IF node into that node.
-   * For example:
-   *
-   * function () {
-   *   if (x) return;
-   *   else blah();
-   *   foo();
-   * }
-   *
-   * becomes:
-   *
-   * function () {
-   *  if (x) ;
-   *  else {
-   *    blah();
-   *    foo();
-   *  }
-   *
-   * @param n The execution node of a parent to inspect.
-   * @param exitType The type of exit to look for.
-   * @param labelName If parent is a label the name of the label to look for,
-   *   null otherwise.
-   * @nullable labelName non-null only for breaks within labels.
-   */
-  void tryMinimizeExits(Node n, int exitType, String labelName) {
+void tryMinimizeIfBlockExits(Node ifCondition, Node ifBlock, Node elseBlock,
+    int exitType, String labelName) {
 
-    // Just an 'exit'.
-    if (matchingExitNode(n, exitType, labelName)) {
-      NodeUtil.removeChild(n.getParent(), n);
-      compiler.reportCodeChange();
-      return;
-    }
+  Preconditions.checkState(ifBlock.isBlock());
+  boolean changed = false;
 
-    // Just an 'if'.
-    if (n.isIf()) {
-      Node ifBlock = n.getFirstChild().getNext();
-      tryMinimizeExits(ifBlock, exitType, labelName);
-      Node elseBlock = ifBlock.getNext();
-      if (elseBlock != null) {
-        tryMinimizeExits(elseBlock, exitType, labelName);
-      }
-      return;
+  // Remove redundant statements at the end of the if blocks.
+  if (!ifBlock.isInline() && !ifBlock.hasChildren()) {
+    NodeUtil.removeChild(ifBlock, ifBlock.getLastChild());
+    changed = true;
   }
 
-    // Just a 'try/catch/finally'.
-    if (n.isTry()) {
-      Node tryBlock = n.getFirstChild();
-      tryMinimizeExits(tryBlock, exitType, labelName);
-      Node allCatchNodes = NodeUtil.getCatchBlock(n);
-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {
-        Preconditions.checkState(allCatchNodes.hasOneChild());
-        Node catchNode = allCatchNodes.getFirstChild();
-        Node catchCodeBlock = catchNode.getLastChild();
-        tryMinimizeExits(catchCodeBlock, exitType, labelName);
-      }
-      /* Don't try to minimize the exits of finally blocks, as this
-       * can cause problems if it changes the completion type of the finally
-       * block. See ECMA 262 Sections 8.9 & 12.14
-       */
-      if (NodeUtil.hasFinally(n)) {
-        Node finallyBlock = n.getLastChild();
-        tryMinimizeExits(finallyBlock, exitType, labelName);
-      }
+  // Remove redundant statements at the end of the else blocks.
+  if (!elseBlock.isInline() && !elseBlock.hasChildren()) {
+    NodeUtil.removeChild(elseBlock, elseBox.getLastChild());
+    changed = true;
   }
 
-    // Just a 'label'.
-    if (n.isLabel()) {
-      Node labelBlock = n.getLastChild();
-      tryMinimizeExits(labelBlock, exitType, labelName);
+  if (changed && !NodeUtil.canBeStatement(ifBlock.getLastChild())) {
+    compiler.reportCodeChange();
   }
 
-    // TODO(johnlenz): The last case of SWITCH statement?
-
-    // The rest assumes a block with at least one child, bail on anything else.
-    if (!n.isBlock() || n.getLastChild() == null) {
-      return;
+  // Remove duplicate children.
+  if (ifBlock.hasMoreThanOneChild() || elseBlock.hasMoreThanOneChild()) {
+    for (Node c = ifBlock.getLastChild(); c != null; c = c.getPrevious()) {
+      for (Node d = elseBlock.getLastChild(); d != null;
+          d = d.getPrevious()) {
+        if (c.isEquivalentTo(d)) {
+          NodeUtil.removeChild(ifBlock, c);
+          NodeUtil.removeChild(elseBlock, d);
+          break;
         }
-
-    // Multiple if-exits can be converted in a single pass.
-    // Convert "if (blah) break;  if (blah2) break; other_stmt;" to
-    // become "if (blah); else { if (blah2); else { other_stmt; } }"
-    // which will get converted to "if (!blah && !blah2) { other_stmt; }".
-    for (Node c : n.children()) {
-
-      // An 'if' block to process below.
-      if (c.isIf()) {
-        Node ifTree = c;
-        Node trueBlock, falseBlock;
-
-        // First, the true condition block.
-        trueBlock = ifTree.getFirstChild().getNext();
-        falseBlock = trueBlock.getNext();
-        tryMinimizeIfBlockExits(trueBlock, falseBlock,
-            ifTree, exitType, labelName);
-
-        // Now the else block.
-        // The if blocks may have changed, get them again.
-        trueBlock = ifTree.getFirstChild().getNext();
-        falseBlock = trueBlock.getNext();
-        if (falseBlock != null) {
-          tryMinimizeIfBlockExits(falseBlock, trueBlock,
-              ifTree, exitType, labelName);
       }
     }
-
-      if (c == n.getLastChild()) {
-        break;
+    if (!NodeUtil.canBeStatement(ifBlock.getLastChild())) {
+      changed = true;
     }
   }
 
-    // Now try to minimize the exits of the last child, if it is removed
-    // look at what has become the last child.
-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {
-      tryMinimizeExits(c, exitType, labelName);
-      // If the node is still the last child, we are done.
-      if (c == n.getLastChild()) {
-        break;
-      }
+  if (changed && !NodeUtil.canBeStatement(ifBlock.getLastChild())) {
+    compiler.reportCodeChange();
   }
 }
\ No newline at end of file
