diff --git a/tmp/a57d5a66-9ca7-491c-8f00-1dc07e12863a_buggy.java b/tmp/a3cfccf7-8745-4e54-97d6-aaac9a80f05a_fixed.java
index 5f8ac1a..24e111a 100644
--- a/tmp/a57d5a66-9ca7-491c-8f00-1dc07e12863a_buggy.java
+++ b/tmp/a3cfccf7-8745-4e54-97d6-aaac9a80f05a_fixed.java
@@ -1,34 +1,6 @@
-    private int compareNodePointers(
-        NodePointer p1,
-        int depth1,
-        NodePointer p2,
-        int depth2) 
-    {
-        if (depth1 < depth2) {
-            int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);
-            return r == 0 ? -1 : r;
-        }
-        if (depth1 > depth2) {
-            int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);
-            return r == 0 ? 1 : r;
-        }
-        if (p1 == null && p2 == null) {
-            return 0;
-        }
 
-        if (p1 != null && p1.equals(p2)) {
-            return 0;
-        }
+This code is a function for comparing the nodes of a tree data structure, and it takes two node pointers (p1 and p2) as input, as well as their depths (depth1 and depth2). The function returns an integer representing the order of the nodes relative to each other in the tree.
 
-        if (depth1 == 1) {
-            throw new JXPathException(
-                    "Cannot compare pointers that do not belong to the same tree: '"
-                            + p1 + "' and '" + p2 + "'");
-        }
-        int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1);
-        if (r != 0) {
-            return r;
-        }
+The basic idea is that the function will compare the two nodes at the current level, and if they are not equal, it will recurse down to the children of the nodes and compare them. If all the children are equal, but one of the nodes is a child of the other, the function will return a non-zero value.
 
-        return p1.parent.compareChildNodePointers(p1, p2);
-    }
+The function also includes the case where both nodes are null, in which case it returns 0.
\ No newline at end of file
