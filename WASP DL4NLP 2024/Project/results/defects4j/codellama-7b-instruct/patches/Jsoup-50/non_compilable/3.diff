diff --git a/tmp/e41e7903-01df-4275-a850-e62ad49d484f_buggy.java b/tmp/453b82cd-0416-4e23-bc94-34b3121e199b_fixed.java
index 25ca093..bbdde4a 100644
--- a/tmp/e41e7903-01df-4275-a850-e62ad49d484f_buggy.java
+++ b/tmp/453b82cd-0416-4e23-bc94-34b3121e199b_fixed.java
@@ -1,52 +1,5 @@
-    // todo - this is getting gnarly. needs a rewrite.
-    static Document parseByteData(ByteBuffer byteData, String charsetName, String baseUri, Parser parser) {
-        String docData;
-        Document doc = null;
-
-        // look for BOM - overrides any other header or input
-
-        if (charsetName == null) { // determine from meta. safe parse as UTF-8
-            // look for <meta http-equiv="Content-Type" content="text/html;charset=gb2312"> or HTML5 <meta charset="gb2312">
-            docData = Charset.forName(defaultCharset).decode(byteData).toString();
-            doc = parser.parseInput(docData, baseUri);
-            Element meta = doc.select("meta[http-equiv=content-type], meta[charset]").first();
-            if (meta != null) { // if not found, will keep utf-8 as best attempt
-                String foundCharset = null;
-                if (meta.hasAttr("http-equiv")) {
-                    foundCharset = getCharsetFromContentType(meta.attr("content"));
-                }
-                if (foundCharset == null && meta.hasAttr("charset")) {
-                    try {
-                        if (Charset.isSupported(meta.attr("charset"))) {
-                            foundCharset = meta.attr("charset");
-                        }
-                    } catch (IllegalCharsetNameException e) {
-                        foundCharset = null;
-                    }
-                }
-
-                if (foundCharset != null && foundCharset.length() != 0 && !foundCharset.equals(defaultCharset)) { // need to re-decode
-                    foundCharset = foundCharset.trim().replaceAll("[\"']", "");
-                    charsetName = foundCharset;
-                    byteData.rewind();
-                    docData = Charset.forName(foundCharset).decode(byteData).toString();
-                    doc = null;
-                }
-            }
-        } else { // specified by content type header (or by user on file load)
-            Validate.notEmpty(charsetName, "Must set charset arg to character set of file to parse. Set to null to attempt to detect from HTML");
-            docData = Charset.forName(charsetName).decode(byteData).toString();
-        }
-        if (docData.length() > 0 && docData.charAt(0) == UNICODE_BOM) {
-            byteData.rewind();
-            docData = Charset.forName(defaultCharset).decode(byteData).toString();
-            docData = docData.substring(1);
-            charsetName = defaultCharset;
-            doc = null;
-        }
-        if (doc == null) {
-            doc = parser.parseInput(docData, baseUri);
-            doc.outputSettings().charset(charsetName);
-        }
-        return doc;
-    }
+  1. The function has a lot of duplicate code that does the same thing in different ways. This makes the function hard to read and maintain.
+  2. The function assumes that it can safely decode the input using the specified character set, but this is not always the case. If the input data is not valid for the character set, the function will crash.
+  3. The function does not correctly parse the HTML data, and will either parse it as incomplete or not at all.
+  4. The function does not correctly convert to the desired character set even if the HTML data is valid.
+  5. The function does not handle Unicode BOMs correctly, which can lead to confusing results.
\ No newline at end of file
